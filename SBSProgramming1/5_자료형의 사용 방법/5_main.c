#include <stdio.h>
#include <stdint.h>

int main()
{
	printf("5강 시작!\n");

	// 정수, 실수 구분해야 한다. 
	// 메모리의 크기를 지정할 수 있다.
	// sizeof
	// 정수 형태의 자료형들 char, short, int, long, long long
	// 1바이트의 크기를 저장할 수 있고 데이터를 읽는 방식은 정수다 + 이름은 number1;
	char number1;           // number1 char 자료형태로 데이터를 저장할 수 있게 변수 선언.
	short number2;
	int number3;
	long number4;
	long long number5;

	printf("char 자료형의 크기 : %llu\n", sizeof(char)); //바이트 크기
	printf("short 자료형의 크기 : %llu\n", sizeof(short));
	printf("int 자료형의 크기 : %llu\n", sizeof(int));
	printf("long 자료형의 크기 : %llu\n", sizeof(long));
	printf("long long 자료형의 크기 : %llu\n", sizeof(long long));

	// int, long 같은 크기의 자료형을 선언한 이유?
	// 자료형 최소 ~ 최대 크기가 지정이 되어있다.
	// 컴파일러 자료형의 크기가 다르다.

	int16_t num1 = 1;     // 8 x 2 = 2 바이트
	int32_t num2 = 1;     // 8 x 4
	int64_t num3 = 1;     // 8 x 8
	printf("int16_t 자료형의 크기 : %llu\n", sizeof(int16_t));
	printf("int32_t 자료형의 크기 : %llu\n", sizeof(int32_t));
	printf("int64_t자료형의 크기 : %llu\n", sizeof(int64_t));
	
	// 1바이트는 8비트기 때문에 이런 결과가 나옴

	// 오버플로우
	// 부호가 있는 정수, 부호가 없는 정수 -> MSB 0, 1 (0 양수, 1 음수)
	// unsigned <- 양수만 표현하겠다. 2^7 -> 2^8   128 양의 정수를 더 표현할 수 있음.
	// ex) 레벨 데이터 표현. 정수 형태의 자료형을 선택하고 싶다.    char, short, int, long, long long

	// 레벨 데이터를 저장할껀데, 어떤 데이터 타입으로 설정하는게 가장 효과적일까?
	// int -> 21억, 충분한 공간을 확보할 수 있음.
	// 최대 레벨 존재. 999,999 -> 적은 크기의 데이터를 저장하는데 불필요한 공간을 사용할 수 있음.
	// 확장이 될 수도 있음.
	// 데미지. 9999억, but int는 21억       2^(4x8) = 42억 정도
	

	char level = 1;     // 0000 0001
	printf("현재 레벨 : %d\n", level);
	level = 1 + 128;        // 0111 1111  127 // 1000 0000
	printf("현재 레벨 : %d\n", level);
	unsigned char level2 = 1; // 0 ~ 최댓값.

	// 음수를 표현하는 방법 고찰.

	// 부호를 표현하는 숫자만 0,1 2진법 나머지를 표현해보자.
	// -5 비트로 표현을 하고 싶다.       000101  -> 4+1 = 5
	// 5 + (-5) = 0
	// 1000101 [-5]
	// 0000101 [5]
	// 1001010 [-10]
	// 두 수를 더하면 0이 되어야한다.
	// 0000101 -> 1111010
	// 비트를 모두 반대로 변환하고 1을 더해준다. -> 2의 보수법

	// 2바이트 short [0000 0000][0000 0001]    1
	//               [1111 1111] [1111 1111]    -1
	// 소수점이 없는 숫자를 표현했음.
	// float, double, long double

	float n1 = 0.00123f;         // 4바이트
	double n2 = 0.00123f;        // 8바이트
	long double n3 = 0.00123f;   
	printf("float 자료형의 크기 : %llu\n", sizeof(float));
	printf("double 자료형의 크기 : %llu\n", sizeof(double));
	printf("long double 자료형의 크기 : %llu\n", sizeof(long double));

	// 4 x 8 비트 공간에서 실수를 표현하기 위한 방법은?
	// (정수)소수점(실수)
	// [        정수   ][      소수점  ]    정수 비트의 맨 앞자리는 부호로 사용   [0][ 7     ][    8   ] -> 24.4 -> 표현할 수 있는 가지수가 너무 적음.
	// 1.00000000000000000000000125
	// 위의 방식은 고정 소수점 방식
	// float 부동소수점, 둥둥 떠다니다

	// 13000    -> 1.3 x 10^4 
	// -13000   -> [1][ 몇 승 증가 했는가?][유효 숫자는 얼마인가?]
	// 0.0123   -> 1.23 x 10^(-2)
	// -0.0123  -> -1.23 x 10^(-2)

	// 컴퓨터는 10진수가 아니라 2진수를 사용함
	// 1.3 x 10^4를 2진수로 표현하는 로직을 사용 -> 여러 방식 중 IEEE754 방식
	// 고정소수점 장점 : 정확한 소수를 표현할 수 있음 / 단점 : 소수를 표현하기에는 공간이 너무 부족함
	// 부동소수점 장점 : 많은 수를 표현할 수 있음 / 단점 : 소수점이 정확하지 않음

	// 특정 조건이 만족하면 어떤 코드를 실행하라.
	float n4 = 0.3;
	float n5 = 0.4;
	float n6 = 0.7;
	if (n6 == n4 + n5) {
		printf("0.7 = 0.3 + 0.4 같습니다.\n");
	}
	else {
		printf("0.7 = 0.3 + 0.4 다릅니다.\n");
	}
	// comment

	// 문자를 표현하는 방법

	char character1 = 97;
	short character2 = 97;
	int character3 = 97;
	double character4 = 97;

	// 똑같은 데이터를 사용하는데 어떻게 사용하느냐에 따라서 결과가 달라진다.
	

	printf("1%c\n", character1);
	printf("2%c\n", character2);   // 문자를 표현 -> 낭비되는 메모리가 있더라
	printf("3%c\n", character3);   // 문자를 표현 -> 낭비되는 메모리가 있더라
	//printf("4%d\n", character4); // character4에는 97값이 안들어 있기 때문에 문자를 제대로 표현하지 못했다.

	// char 문자를 표현하는 타입이다.
	// 그래서 한글은?
	// 자음 + 모음 , 자음 + 모음 + 자음
	// 조합형 쓸까?
	// 완성형 쓸까? ex) 가 -> 특정 숫자 char는 128개만 가능 한글을 표현하기에는 너무 부족함
	// 히라가나, 가타가나, 한자
	// EUC_KR 2350 한글로 표현 ? 안됨 -> CP949(2바이트) 모든 한글을 표현할 수 있도록 대응되도록 만들었습니다.
	// ANSI
	// UTF-8(3바이트) 유니코드, 통일성
	// [EUC_KR] 인코딩 되어 있는 코드를 UTF-8 바꾸는 API
	// 한글을 표현하는 방식에 대해서 조사.      문자를 한글에서 2진법으로 : 인코딩 /  000101010(2) -> 한글 :  디코딩
}